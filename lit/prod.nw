@
\section{Procedures}
As section {\tt Interface} said,
a procedure is a code chunk that runs within one layer,
perform a specific task in the current execution environment.
It's better to point out that a procedure can be represented as a traditional function,
but not must.
I have done this work with an approach called literate programming,
so, a code chunk here is just a code chunk with a name attached,
functions use these names to include procedures
to perform tasks indicated by the names.
Names should be carefully studied, all names share a common namespace,
a name ought to be able to express which layer the procedure runs at and what it take effects on.

The following sections describe this layer's execution environment first, 
then the procedures excerpted from modules that belong to this layer.

@
Some common code used by all modules.
<<common data types>>=
typedef unsigned char	uint8;
typedef unsigned short	uint16;
typedef unsigned int	uint32;
typedef unsigned long	uint64;

<<repertoire of driver layer>>=
<<common data types>>

<<repertoire of subsystem layer>>=
<<common data types>>

@
\subsection{Driver Layer}
This layer talk to machine directly, 
the major actions of this layer are usually direct memory and register accessings.
The modules run in this layer should have a knowledge of CPU's type and memory's layout.

@
The maximum number of CPUs is assumed to be 4, and {\tt MOS} is built for {\tt RISC-V} machine.
<<repertoire of driver layer>>=
#define NCPU 	8
#define ISA	"RISC-V"

@ %def NCPU ISA

@
The only way to access register is through assembly code,
so defining C~interface to {\tt RISC-V} architecture is useful.

<<repertoire of driver layer>>=
<<riscv: types>>
<<riscv: macros and inline functions>>

@
Some useful macros.
<<riscv: macros and inline functions>>=
#define ASM(s) asm volatile(s)
#define ASM_W(s) asm volatile(s::"r" (x))
#define ASM_R(s) asm volatile(s:"=r" (x))

@ %def ASM ASM_W ASM_R

@
Which hart (core) is this?
<<riscv: macros and inline functions>>=
inline uint64 r_mhartid()
{
	uint64 x;
	ASM_R("csrr %0, mhartid");
	return x;
}

@ %def r_mhartid

@
Machine Status Register, mstatus.

<<riscv: macros and inline functions>>=
#define MSTATUS_MPP_MASK (3L << 11)	/* previous mode. */
#define MSTATUS_MPP_M (3L << 11)
#define MSTATUS_MPP_S (1L << 11)
#define MSTATUS_MPP_U (0L << 11)
#define MSTATUS_MIE (1L << 3)	 /* machine-mode interrupt enable. */

inline uint64 r_mstatus()
{
	uint64 x;
	ASM_R("csrr %0, mstatus");
	return x;
}

inline void w_mstatus(uint64 x)
{
	ASM_W("csrw mstatus, %0");
}

@ %def MSTATUS_MPP_MASK MSTATUS_MPP_M MSTATUS_MPP_S MSTATUS_MPP_U MSTATUS_MIE
@ %def r_mstatus w_mstatus

@
Machine exception program counter,
holds the instruction address to which a return from
exception will go.
<<riscv: macros and inline functions>>=
inline void w_mepc(uint64 x)
{
	ASM_W("csrw mepc, %0");
}

@ %def w_mepc

@
Supervisor Status Register, sstatus.

<<riscv: macros and inline functions>>=
#define SSTATUS_SPP (1L << 8)	/* Previous mode, 1=Supervisor, 0=User */
#define SSTATUS_SPIE (1L << 5)	/* Supervisor Previous Interrupt Enable */
#define SSTATUS_UPIE (1L << 4)	/* User Previous Interrupt Enable */
#define SSTATUS_SIE (1L << 1)	/* Supervisor Interrupt Enable */
#define SSTATUS_UIE (1L << 0)	/* User Interrupt Enable */

inline uint64 r_sstatus()
{
	uint64 x;
	ASM_R("csrr %0, sstatus");
	return x;
}

inline void w_sstatus(uint64 x)
{
	ASM_W("csrw sstatus, %0");
}

@ %def SSTATUS_SPP SSTATUS_SPIE SSTATUS_UPIE SSTATUS_SIE SSTATUS_UIE
@ %def r_sstatus w_sstatus

@
Supervisor Interrupt Pending.
<<riscv: macros and inline functions>>=
inline uint64 r_sip()
{
	uint64 x;
	ASM_R("csrr %0, sip");
	return x;
}

inline void w_sip(uint64 x)
{
	ASM_W("csrw sip, %0");
}

@ %def r_sip w_sip

@
Supervisor Interrupt Enable.
<<riscv: macros and inline functions>>=
#define SIE_SEIE (1L << 9)	/* external */
#define SIE_STIE (1L << 5)	/* timer */
#define SIE_SSIE (1L << 1)	/* software */

inline uint64 r_sie()
{
	uint64 x;
	ASM_R("csrr %0, sie");
	return x;
}

inline void w_sie(uint64 x)
{
	ASM_W("csrw sie, %0");
}

@ %def SIE_SEIE SIE_STIE SIE_SSIE
@ %def r_sie w_sie

@
Machine-mode Interrupt Enable.
<<riscv: macros and inline functions>>=
#define MIE_MEIE (1L << 11)	/* external */
#define MIE_MTIE (1L << 7)	/* timer */
#define MIE_MSIE (1L << 3)	/* software */

inline uint64 r_mie()
{
	uint64 x;
	ASM_R("csrr %0, mie");
	return x;
}

inline void w_mie(uint64 x)
{
	ASM_W("csrw mie, %0");
}

@ %def MIE_MEIE MIE_MTIE MIE_MSIE
@ %def r_mie w_mie

@
Supervisor exception program counter, holds the
instruction address to which a return from
exception will go.
<<riscv: macros and inline functions>>=
inline void w_sepc(uint64 x)
{
	ASM_W("csrw sepc, %0");
}

inline uint64 r_sepc()
{
	uint64 x;
	ASM_R("csrr %0, sepc");
	return x;
}

@ %def w_sepc r_sepc

@
Machine Exception Delegation.
<<riscv: macros and inline functions>>=
inline uint64 r_medeleg()
{
	uint64 x;
	ASM_R("csrr %0, medeleg");
	return x;
}

inline void w_medeleg(uint64 x)
{
	ASM_W("csrw medeleg, %0");
}

@ %def r_medeleg w_medeleg

@
Machine Interrupt Delegation.
<<riscv: macros and inline functions>>=
inline uint64 r_mideleg()
{
	uint64 x;
	ASM_R("csrr %0, mideleg");
	return x;
}

inline void w_mideleg(uint64 x)
{
	ASM_W("csrw mideleg, %0");
}

@ %def r_mideleg w_mideleg

@
Supervisor Trap-Vector Base Address,
low two bits are mode.
<<riscv: macros and inline functions>>=
inline void w_stvec(uint64 x)
{
	ASM_W("csrw stvec, %0");
}

inline uint64 r_stvec()
{
	uint64 x;
	ASM_R("csrr %0, stvec");
	return x;
}

@ %def w_stvec r_stvec

@
Machine-mode interrupt vector.
<<riscv: macros and inline functions>>=
inline void w_mtvec(uint64 x)
{
	ASM_W("csrw mtvec, %0");
}

@ %def w_mtvec

@
Use riscv's sv39 page table scheme.
<<riscv: macros and inline functions>>=
#define SATP_SV39 (8L << 60)

#define MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) >> 12))

@ %def SATP_SV39 MAKE_SATP

@
Supervisor address translation and protection;
holds the address of the page table.
<<riscv: macros and inline functions>>=
inline void w_satp(uint64 x)
{
	ASM_W("csrw satp, %0");
}

inline uint64 r_satp()
{
	uint64 x;
	ASM_R("csrr %0, satp");
	return x;
}

@ %def w_satp r_satp

@
Supervisor Scratch register.
<<riscv: macros and inline functions>>=
inline void w_sscratch(uint64 x)
{
	ASM_W("csrw sscratch, %0");
}

inline void w_mscratch(uint64 x)
{
	ASM_W("csrw mscratch, %0");
}

@ %def w_sscratch w_msscratch

@
Supervisor Trap Cause.
<<riscv: macros and inline functions>>=
inline uint64 r_scause()
{
	uint64 x;
	ASM_R("csrr %0, scause");
	return x;
}

@ %def r_scause

@
Supervisor Trap Value.
<<riscv: macros and inline functions>>=
inline uint64 r_stval()
{
	uint64 x;
	ASM_R("csrr %0, stval");
	return x;
}

@ %def r_stval

@
Machine-mode Counter-Enable.
<<riscv: macros and inline functions>>=
inline void w_mcounteren(uint64 x)
{
	ASM_W("csrw mcounteren, %0");
}

inline uint64 r_mcounteren()
{
	uint64 x;
	ASM_R("csrr %0, mcounteren");
	return x;
}

@ %def w_mcounteren r_mcounteren

@
Machine-mode cycle counter.
<<riscv: macros and inline functions>>=
inline uint64 r_time()
{
	uint64 x;
	ASM_R("csrr %0, time");
	return x;
}

@ %def r_time

@
Enable device interrupts.
<<riscv: macros and inline functions>>=
inline void intr_on()
{
	w_sstatus(r_sstatus() | SSTATUS_SIE);
}

@ %def intr_on

@
Disable device interrupts.
<<riscv: macros and inline functions>>=
inline void intr_off()
{
	w_sstatus(r_sstatus() & ~SSTATUS_SIE);
}

@ %def intr_off

@
Are device interrupts enabled?
<<riscv: macros and inline functions>>=
inline int intr_get()
{
	uint64 x = r_sstatus();
	return (x & SSTATUS_SIE) != 0;
}

@ %def intr_get

@
Get stack pointer.
<<riscv: macros and inline functions>>=
inline uint64 r_sp()
{
	uint64 x;
	ASM_R("mv %0, sp");
	return x;
}

@ %def r_sp

@
Read and write {\tt tp}, the thread pointer, which holds
this core's hartid (core number). 
<<riscv: macros and inline functions>>=
inline uint64 r_tp()
{
	uint64 x;
	ASM_R("mv %0, tp");
	return x;
}

inline void w_tp(uint64 x)
{
	ASM_W("mv tp, %0");
}

@ %def r_tp w_tp

@
Read {\tt ra}.
<<riscv: macros and inline functions>>=
inline uint64 r_ra()
{
	uint64 x;
	ASM_R("mv %0, ra");
	return x;
}

@ %def r_ra

@
Flush the TLB.
<<riscv: macros and inline functions>>=
inline void sfence_vma()
{
	ASM("sfence.vma zero, zero");
	/* the zero, zero means flush all TLB entries. */
}

@ %def sfence_vma

@
Pagetable.
<<riscv: macros and inline functions>>=
#define PGSIZE 4096		/* bytes per page */
#define PGSHIFT 12		/* bits of offset within a page */

#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))

#define PTE_V (1L << 0)		/* valid */
#define PTE_R (1L << 1)
#define PTE_W (1L << 2)
#define PTE_X (1L << 3)
#define PTE_U (1L << 4)		/* 1 -> user can access */

/* shift a physical address to the right place for a PTE. */
#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10) 

#define PTE2PA(pte) (((pte) >> 10) << 12)

#define PTE_FLAGS(pte) ((pte) & 0x3FF)

/* extract the three 9-bit page table indices from a virtual address. */
#define PXMASK          0x1FF	/* 9 bits */
#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)

/*
 * one beyond the highest possible virtual address.
 * MAXVA is actually one bit less than the max allowed by
 * Sv39, to avoid having to sign-extend virtual addresses
 * that have the high bit set.
*/
#define MAXVA (1L << (9 + 9 + 9 + 12 - 1))

<<riscv: types>>=
typedef uint64 pte_t;
typedef uint64 *pagetable_t;	/* 512 PTEs */

@
Memory layout differs from one machine to another, because {\tt MOS} is supposed to be able to
run on {\tt qemu-virt}, I set up the layout so.
<<repertoire of driver layer>>=
<<memory layout of qemu-virt>>

@
{\tt qemu-virt} is set up like this,
based on qemu's {\tt hw/riscv/virt.c}.

{\tt 00001000}: boot ROM, provide by \.{qemu}\par
{\tt 02000000}: CLINT\par
{\tt 0C000000}: PLIC\par
{\tt 10000000}: uart0\par
{\tt 10001000}: virtio disk\par
{\tt 80000000}: boot ROM jumps here in machine mode,\par
commond line option {\tt -kernel} loads the kernel here

The kernel uses physical memory thus:

{\tt 80000000}: {\tt entry.S}, then kernel's text and data\par
end: start of page allocation area\par
PHYSTOP: kernel space's end at RAM

<<memory layout of qemu-virt>>=
<<uart0's controller>>
<<virtio's controller>>
<<CLINT's controller>>
<<PLIC's controller>>

@
\.{qemu} puts UART registers here in physical memory.
<<uart0's controller>>=
#define UART0 0x10000000L
#define UART0_IRQ 10

<<virtio's controller>>=
#define VIRTIO0 0x10001000L
#define VIRTIO0_IRQ 1

<<CLINT's controller>>=
#define CLINT 0x02000000L
#define CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid))
#define CLINT_MTIME (CLINT + 0xBFF8) /* cycles since boot */

<<PLIC's controller>>=
#define PLIC 0x0c000000L
#define PLIC_PRIORITY (PLIC + 0x0)
#define PLIC_PENDING (PLIC + 0x1000)
#define PLIC_MENABLE(hart) (PLIC + 0x2000 + (hart)*0x100)
#define PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)
#define PLIC_MPRIORITY(hart) (PLIC + 0x200000 + (hart)*0x2000)
#define PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)
#define PLIC_MCLAIM(hart) (PLIC + 0x200004 + (hart)*0x2000)
#define PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)

@
Besides memory layout that determinded by machine's specification,
there are also some defined by kernel.
The kernel expects there to be {\tt RAM}
for use by the kernel and user pages
from physical address [[0x80000000]] to [[PHYSTOP]].

<<repertoire of driver layer>>=
<<kernel's layout>>

<<kernel's layout>>=
#define KERNBASE 0x80000000L
#define PHYSTOP (KERNBASE + 128*1024*1024) /* 128MB */

<<trampoline's location>>
<<kernel stacks' location>>

@
Map the trampoline page to the highest address,
in both user and kernel space.
<<trampoline's location>>=
#define TRAMPOLINE (MAXVA - PGSIZE)

@
Map kernel stacks beneath the trampoline,
each surrounded by invalid guard pages.
<<kernel stacks' location>>=
#define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)

@
\subsubsection{Boot}

@ 
A 4096-byte stack per CPU,
stacks is defined in succeeding C~code.

<<prepare per CPU stack>>=
csrr a1, mhartid

la sp, stack0
li a0, 4096
addi a1, a1, 1
mul a0, a0, a1
add sp, sp, a0

@
The interface of succeeding C~code is [[start]].
<<continue with C code>>=
call start

@
To ensure following booting continue correctly, should do:

1. disable paging of supervisor mode for now, the pagatable has not built yet.\par
2. delegate interrupts and exceptions to supervisor mode to avoid accidents.

<<set up initial status of CPU>>=
w_satp(0); /* disable paging */
w_medeleg(0xffff);
/* delegate interrupts and exceptions to supervisor mode */
w_mideleg(0xffff);
w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);

w_tp(r_mhartid()); /* set thread pointer to correct value */

@
This step's purpose is to set up as if [[start]] is called from 
supervisor mode.
<<prepare for switching to supervisor mode>>=
{
	extern void main(); 

	w_mstatus((r_mstatus() & ~MSTATUS_MPP_MASK) | MSTATUS_MPP_S );
	w_mepc((uint64)main); /* return to [[main]] */
}

