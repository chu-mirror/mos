@
\section{Procedures}
A procedure is a code chunk that runs within one layer,
perform a specific task in the current execution environment.
It's better to point out that a procedure can be represented as a traditional function
but not must.
I have done this work by the power from literate programming,
a code chunk here is just a code chunk with a name attached,
functions use these names to include procedures
to perform tasks indicated by the names.
Names should be carefully studied, all names share a common namespace,
a name ought to be able to express which layer the procedure runs at and what it take effects on.

@
\subsection{Driver Layer}
@
\subsubsection{Boot}

@ 
A 4096-byte stack per CPU,
stacks is defined in succeeding C~code.

<<prepare per CPU stack>>=
csrr a1, mhartid

la sp, stack0
li a0, 4096
addi a1, a1, 1
mul a0, a0, a1
add sp, sp, a0

@
The interface of succeeding C~code is [[start]].
<<continue with C code>>=
call start

@
To ensure following booting continue correctly, should do:

1. disable paging of supervisor mode for now, the pagatable has not built yet.\par
2. delegate interrupts and exceptions to supervisor mode to avoid accidents.

<<set up initial status of CPU>>=
w_satp(0); /* disable paging */
w_medeleg(0xffff);
/* delegate interrupts and exceptions to supervisor mode */
w_mideleg(0xffff);
w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);

w_tp(r_mhartid()); /* set thread pointer to correct value */

@
This step's purpose is to set up as if [[start]] is called from 
supervisor mode.
<<prepare for switching to supervisor mode>>=
{
	extern void main(); 

	w_mstatus((r_mstatus() & ~MSTATUS_MPP_MASK) | MSTATUS_MPP_S );
	w_mepc((uint64)main); /* return to [[main]] */
}

