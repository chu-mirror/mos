@
\section{Boot}
This chapter defined boot process of \.{MOS}.

Use three modules to handle this process, {\tt entry}, {\tt start}, {\tt main}.
The previous two run at driver layer, {\tt main} run at subsystem layer.

@
\subsection{entry}
Start with assembly code, turn to C~code after initialization of stacks.

<<entry's functions>>=
.global _entry
_entry:
	<<prepare per CPU stack>>
	<<continue with C code>>
spin:
	j spin

@
\subsection{start}
Now, turn to C~code.

<<start's repertoire>>=
<<repertoire of driver layer>>

@
[[stack0]] is defined here.
<<start's data>>=
__attribute__ ((aligned (16))) char stack0[4096 * NCPU];
@ %def stack0

@
[[start]] is the main routine of boot in machine mode.
<<start's functions>>=
void
start()
{
	<<initialize CPU's status>>
	extern void main();
	main();
}
@ %def start

<<initialize CPU's status>>=

@
\subsection{main}

<<main's repertoire>>=
<<repertoire of subsystem layer>>
<<log's interface>>

inline int getcpu() {
	int x;
	asm volatile("csrr %0, mhartid": "=r" (x));
	return x;
}

<<main's functions>>=
void
main()
{
	volatile static int started = 0;
	if (getcpu() == 0) {
		uartinit();
		printf_init();
		printf("Hello World!\nFrom CPU %d\nThe pointer %p\n%s\n", -10, 16*15, "I lo\n");
		__sync_synchronize();
		started = 1;
	} else {
		while (started == 0)
			;
		printf("Hello World!\nFrom CPU %d\nThe pointer %p\n%s\n", -10, 16*15, "I lo\n");
	}

	while(1);
}

@ %def main
