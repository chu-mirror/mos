@
\section{Specifications}
Specifications of this operating system and the hardware that {\tt OS} is built on.
I copied them verbatim from {\tt xv6-riscv} source code,
but delete and reorganize some parts to fit my own requirements.

\subsection{Operating System}
This section defined some parameters used in compiling,
classified according to subsystems they described.

<<param.h>>=
#ifndef MOS_PARAM
#define MOS_PARAM

<<proc's params>>

#endif
<<proc's params>>=
#define NPROC		64	/* maxinum number of processes */
#define NCPU		2	/* maxinum number of CPUs, K201 has two */
@
\subsection{Types used in code}
This section introduced some types used in code,
you can rely on the numbers indicated by their names.

<<types.h>>=

#ifndef MOS_TYPE
#define MOS_TYPE

typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int  uint32;
typedef unsigned long uint64;

#endif

@
\subsection{Physical memory layout}

{\tt qemu-machine} virt is set up like this,
based on qemu's {\tt hw/riscv/virt.c}.

{\tt 00001000}: boot ROM, provide by \.{qemu}\par
{\tt 02000000}: CLINT\par
{\tt 0C000000}: PLIC\par
{\tt 10000000}: uart0\par
{\tt 10001000}: virtio disk\par
{\tt 80000000}: boot ROM jumps here in machine mode,\par
commond line option {\tt -kernel} loads the kernel here

The kernel uses physical memory thus:

{\tt 80000000}: {\tt entry.S}, then kernel's text and data\par
end: start of page allocation area\par
PHYSTOP: kernel space's end at RAM

<<memlayout.h>>=
#ifndef MOS_MEMORY_LAYOUT
#define MOS_MEMORY_LAYOUT

<<uart0's interface>>
<<virtio's interface>>
<<CLINT's interface>>
<<PLIC's interface>>
<<kernel's layout>>
<<trampoline's location>>
<<kernel stacks' location>>
<<user memory layout>>

#endif

@ \.{qemu} puts UART registers here in physical memory.
<<uart0's interface>>=
#define UART0 0x10000000L
#define UART0_IRQ 10

<<virtio's interface>>=
#define VIRTIO0 0x10001000L
#define VIRTIO0_IRQ 1

<<CLINT's interface>>=
#define CLINT 0x02000000L
#define CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid))
#define CLINT_MTIME (CLINT + 0xBFF8) /* cycles since boot */

<<PLIC's interface>>=
#define PLIC 0x0c000000L
#define PLIC_PRIORITY (PLIC + 0x0)
#define PLIC_PENDING (PLIC + 0x1000)
#define PLIC_MENABLE(hart) (PLIC + 0x2000 + (hart)*0x100)
#define PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)
#define PLIC_MPRIORITY(hart) (PLIC + 0x200000 + (hart)*0x2000)
#define PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)
#define PLIC_MCLAIM(hart) (PLIC + 0x200004 + (hart)*0x2000)
#define PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)

@ the kernel expects there to be RAM
for use by the kernel and user pages
from physical address [[0x80000000]] to [[PHYSTOP]].

<<kernel's layout>>=
#define KERNBASE 0x80000000L
#define PHYSTOP (KERNBASE + 128*1024*1024)

@ map the trampoline page to the highest address,
in both user and kernel space.
<<trampoline's location>>=
#define TRAMPOLINE (MAXVA - PGSIZE)

@ map kernel stacks beneath the trampoline,
each surrounded by invalid guard pages.
<<kernel stacks' location>>=
#define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)

@ User memory layout.

Address zero first:

text\par
original data and bss\par
fixed-size stack\par
expandable heap\par
...\par
TRAPFRAME (p->trapframe, used by the trampoline)\par
TRAMPOLINE (the same page as in the kernel)

<<user memory layout>>=
#define TRAPFRAME (TRAMPOLINE - PGSIZE)


@
\subsection{RISC-V}

This chapter defined C~interface to risc-v architecture.
<<riscv.h>>=
#ifndef MOS_RISCV_SPEC
#define MOS_RISCV_SPEC

#include "types.h"

<<riscv: types>>
<<riscv: macros and inline functions>>

#endif

<<riscv: macros and inline functions>>=
#define ASM(s) asm volatile(s)
#define ASM_W(s) asm volatile(s::"r" (x))
#define ASM_R(s) asm volatile(s:"=r" (x))

@ Which hart (core) is this?
<<riscv: macros and inline functions>>=
inline uint64 r_mhartid()
{
	uint64 x;
	ASM_R("csrr %0, mhartid");
	return x;
}

@ Machine Status Register, mstatus.

<<riscv: macros and inline functions>>=
#define MSTATUS_MPP_MASK (3L << 11)	/* previous mode. */
#define MSTATUS_MPP_M (3L << 11)
#define MSTATUS_MPP_S (1L << 11)
#define MSTATUS_MPP_U (0L << 11)
#define MSTATUS_MIE (1L << 3)	 /* machine-mode interrupt enable. */

inline uint64 r_mstatus()
{
	uint64 x;
	ASM_R("csrr %0, mstatus");
	return x;
}

inline void w_mstatus(uint64 x)
{
	ASM_W("csrw mstatus, %0");
}

@ Machine exception program counter,
holds the instruction address to which a return from
exception will go.
<<riscv: macros and inline functions>>=
inline void w_mepc(uint64 x)
{
	ASM_W("csrw mepc, %0");
}

@ Supervisor Status Register, sstatus.

<<riscv: macros and inline functions>>=
#define SSTATUS_SPP (1L << 8)	// Previous mode, 1=Supervisor, 0=User
#define SSTATUS_SPIE (1L << 5)	// Supervisor Previous Interrupt Enable
#define SSTATUS_UPIE (1L << 4)	// User Previous Interrupt Enable
#define SSTATUS_SIE (1L << 1)	// Supervisor Interrupt Enable
#define SSTATUS_UIE (1L << 0)	// User Interrupt Enable

inline uint64 r_sstatus()
{
	uint64 x;
	ASM_R("csrr %0, sstatus");
	return x;
}

inline void w_sstatus(uint64 x)
{
	ASM_W("csrw sstatus, %0");
}

@ Supervisor Interrupt Pending.
<<riscv: macros and inline functions>>=
inline uint64 r_sip()
{
	uint64 x;
	ASM_R("csrr %0, sip");
	return x;
}

inline void w_sip(uint64 x)
{
	ASM_W("csrw sip, %0");
}

@ Supervisor Interrupt Enable.
<<riscv: macros and inline functions>>=
#define SIE_SEIE (1L << 9)	/* external */
#define SIE_STIE (1L << 5)	/* timer */
#define SIE_SSIE (1L << 1)	/* software */

inline uint64 r_sie()
{
	uint64 x;
	ASM_R("csrr %0, sie");
	return x;
}

inline void w_sie(uint64 x)
{
	ASM_W("csrw sie, %0");
}

@ Machine-mode Interrupt Enable.
<<riscv: macros and inline functions>>=
#define MIE_MEIE (1L << 11)	/* external */
#define MIE_MTIE (1L << 7)	/* timer */
#define MIE_MSIE (1L << 3)	/* software */

inline uint64 r_mie()
{
	uint64 x;
	ASM_R("csrr %0, mie");
	return x;
}

inline void w_mie(uint64 x)
{
	ASM_W("csrw mie, %0");
}

@ Supervisor exception program counter, holds the
instruction address to which a return from
exception will go.
<<riscv: macros and inline functions>>=
inline void w_sepc(uint64 x)
{
	ASM_W("csrw sepc, %0");
}

inline uint64 r_sepc()
{
	uint64 x;
	ASM_R("csrr %0, sepc");
	return x;
}

@ Machine Exception Delegation.
<<riscv: macros and inline functions>>=
inline uint64 r_medeleg()
{
	uint64 x;
	ASM_R("csrr %0, medeleg");
	return x;
}

inline void w_medeleg(uint64 x)
{
	ASM_W("csrw medeleg, %0");
}

@ Machine Interrupt Delegation.
<<riscv: macros and inline functions>>=
inline uint64 r_mideleg()
{
	uint64 x;
	ASM_R("csrr %0, mideleg");
	return x;
}

inline void w_mideleg(uint64 x)
{
	ASM_W("csrw mideleg, %0");
}

@ Supervisor Trap-Vector Base Address,
low two bits are mode.
<<riscv: macros and inline functions>>=
inline void w_stvec(uint64 x)
{
	ASM_W("csrw stvec, %0");
}

inline uint64 r_stvec()
{
	uint64 x;
	ASM_R("csrr %0, stvec");
	return x;
}

@ Machine-mode interrupt vector.
<<riscv: macros and inline functions>>=
inline void w_mtvec(uint64 x)
{
	ASM_W("csrw mtvec, %0");
}

@ use riscv's sv39 page table scheme.
<<riscv: macros and inline functions>>=
#define SATP_SV39 (8L << 60)

#define MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) >> 12))

@ supervisor address translation and protection;
holds the address of the page table.
<<riscv: macros and inline functions>>=
inline void w_satp(uint64 x)
{
	ASM_W("csrw satp, %0");
}

inline uint64 r_satp()
{
	uint64 x;
	ASM_R("csrr %0, satp");
	return x;
}

@ Supervisor Scratch register, for early trap handler in trampoline.S.
<<riscv: macros and inline functions>>=
inline void w_sscratch(uint64 x)
{
	ASM_W("csrw sscratch, %0");
}

inline void w_mscratch(uint64 x)
{
	ASM_W("csrw mscratch, %0");
}

@ Supervisor Trap Cause.
<<riscv: macros and inline functions>>=
inline uint64 r_scause()
{
	uint64 x;
	ASM_R("csrr %0, scause");
	return x;
}

@ Supervisor Trap Value.
<<riscv: macros and inline functions>>=
inline uint64 r_stval()
{
	uint64 x;
	ASM_R("csrr %0, stval");
	return x;
}

@ Machine-mode Counter-Enable.
<<riscv: macros and inline functions>>=
inline void w_mcounteren(uint64 x)
{
	ASM_W("csrw mcounteren, %0");
}

inline uint64 r_mcounteren()
{
	uint64 x;
	ASM_R("csrr %0, mcounteren");
	return x;
}

@ machine-mode cycle counter.
<<riscv: macros and inline functions>>=
inline uint64 r_time()
{
	uint64 x;
	ASM_R("csrr %0, time");
	return x;
}

@ enable device interrupts.
<<riscv: macros and inline functions>>=
inline void intr_on()
{
	w_sstatus(r_sstatus() | SSTATUS_SIE);
}

@ disable device interrupts.
<<riscv: macros and inline functions>>=
inline void intr_off()
{
	w_sstatus(r_sstatus() & ~SSTATUS_SIE);
}

@ are device interrupts enabled?
<<riscv: macros and inline functions>>=
inline int intr_get()
{
	uint64 x = r_sstatus();
	return (x & SSTATUS_SIE) != 0;
}

inline uint64 r_sp()
{
	uint64 x;
	ASM_R("mv %0, sp");
	return x;
}

@ read and write tp, the thread pointer, which holds
this core's hartid (core number), the index into cpus[].
<<riscv: macros and inline functions>>=
inline uint64 r_tp()
{
	uint64 x;
	ASM_R("mv %0, tp");
	return x;
}

inline void w_tp(uint64 x)
{
	ASM_W("mv tp, %0");
}

inline uint64 r_ra()
{
	uint64 x;
	ASM_R("mv %0, ra");
	return x;
}

@ flush the TLB.
<<riscv: macros and inline functions>>=
inline void sfence_vma()
{
	ASM("sfence.vma zero, zero");
	/* the zero, zero means flush all TLB entries. */
}

@ pagetable.
<<riscv: macros and inline functions>>=
#define PGSIZE 4096		/* bytes per page */
#define PGSHIFT 12		/* bits of offset within a page */

#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))

#define PTE_V (1L << 0)		/* valid */
#define PTE_R (1L << 1)
#define PTE_W (1L << 2)
#define PTE_X (1L << 3)
#define PTE_U (1L << 4)		/* 1 -> user can access */

/* shift a physical address to the right place for a PTE. */
#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10) 

#define PTE2PA(pte) (((pte) >> 10) << 12)

#define PTE_FLAGS(pte) ((pte) & 0x3FF)

/* extract the three 9-bit page table indices from a virtual address. */
#define PXMASK          0x1FF	/* 9 bits */
#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)

/*
 * one beyond the highest possible virtual address.
 * MAXVA is actually one bit less than the max allowed by
 * Sv39, to avoid having to sign-extend virtual addresses
 * that have the high bit set.
*/
#define MAXVA (1L << (9 + 9 + 9 + 12 - 1))

<<riscv: types>>=
typedef uint64 pte_t;
typedef uint64 *pagetable_t;	/* 512 PTEs */
